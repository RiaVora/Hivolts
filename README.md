# Hivolts
PURPOSE: The purpose of the Hivolts project is to create a 12 by 12 grid game according to the specification file provided by Chris Kuszmaul of the game named “Hivolts” created by either Thomas Ahasic or Douglas Jones, which requires movement connected to keyboard keys, fences, mhos (monsters), a user, and interactive gameplay. “Hivolts” in its full 1970’s graphics is displayed in the first image below (the code created by group is the second image) in which the game consisted of a single user, 12 randomly distributed mhos, 10 randomly distributed interior fences, and a border of outside fences. This original version represents the user as a happy face, the mhos as a sad face, and the fences as two horizontal lines with three squiggly vertical lines in between.  The game had keys corresponding to user movement for stay, up, down, right, left, diagonal up-right, diagonal up-left, diagonal down-right, diagonal down-left, and jump, and gave the mho’s flexibility of all of these directions as well. Gameplay consisted of the user moving in one direction, in which the mho’s would respond by gravitating towards the user. A specific set of rules are set for this gravitation, allowing the mho to die in a fence with pure vertical and horizontal movement, but restricting a more intelligent movement of the mho’s when diagonal movement was considered. At every move the user makes, the mhos move towards the user, including the movement of stay. The one exception to this is the user movement of jump, which places the user on a random point of the inner 10 by 10 grid, but guarantees that the user will not land on a fence, but can lend on an mho (instant death) or an empty space. The specifications given included these requirements, including some ambiguity surrounding the movement of the mhos, and also asked for creativity in the appearance of the game board. I completed this project with two other people, Zage Strassberg-Phillips and Sabrina Martin. The code we created fulfills these specifications to the best of my ability, but still stands for improvement. There is one main point that stands out, for diagonal movement, the mho, finding it’s two main pathways blocked, chooses the vertical/horizontal pathway. This change was created intentionally for ease of user play, and increased the chances of winning the game and enjoyment of it. Based on the ambiguity of the project and the creativity and uniqueness asked in the instructions, this is one of the changes we made to our code. As explained in the pre-plan, we broke hivolts into four parts: the board, the graphics, the mho’s & fences, and the user interaction. To break up the work between the three of us, I tackled the graphics, instantiating the board, the user's movement, and the organization. Zage completed the Mhos move method, the fences, and the mho’s interaction. Sabrina coded the work for the KeyListener, the game over and wining methods, and the resetting of the game. Lastly, we faced many challenges throughout completing hivolts, specifically with the creation of the Mhos move method and the KeyListener, but were able to overcome them with help from other classmates, Kuszmaul, Tutorial Point, and Stack Overflow. Through these challenges, the plan, analysis, and errors, we have been able to create a replica of the 1970’s “Hivolts” game following the details in the instructional file.

FULFILLMENT OF SPECIFICATION: My Java code successfully fulfills the requirements from the specification file (picture shown to the left) with exact movements, the correct user, mho, and fence interaction, a game board, and an 10 by 10 randomized grid with a border of fences. The mho’s move as corresponding to the specification file and the 1970’s game, except for the modification aforementioned. The user moves correctly with each of the 9 movement keys, and jumps to a random position with the touch of the jump key. Also, we added interaction with the “p” key to restart the game. The user appropriately dies when landing on the same space as a fence or an mho, the reason cited as “you ran into something”. If an mho reaches the user, then the reason cited is “an mho ate you”. And, lastly, if the jump method places the user on an mho, the reason cited is “you landed on an mho”. The game board contains a fully fenced border, and the inside 10 by 10 contains the 10 fences, 12 mhos, and one user randomly placed on the board, but all in separate places. This entire setup is represented with the two dimensional array ps[][] (position array), where an “x” represents an empty space, an “S” represents the user, an “M” represents an mho, and an “F” represents a fence.

ERROR EXPLANATION: Our hivolts game meets all of the expectations detailed in the project, and therefore falls short in no areas but in the area of purposeful change, as aforementioned. However, as beginning coders, our code could contain loopholes and other smaller kinks we did not address or find. This possibility leads us hesitant to conclude that our code that follows the specifications perfectly, but instead claim to have code that follows the general idea of the instruction file and adds a bit of creativity into a few elements, as asked. For this possibility of error, I would like to learn how to find and create methods to search for problems or loopholes in a set of methods or classes. Overall, the one major parts of the flag code I would improve is the lack of experience, and perhaps creating a separate level where the mho dies diagonally to increase the difficulty of the game.

OVERVIEW: First, the code creates a two dimensional String array called the position array (ps[][]), which is initialized to contain all “x”s, and then the user, fences, and mhos are added with their specific requirements and with no overlap. First, following my pre-plan, this position array is printed on the console as a game board. This board was created by me, with help from Zage. The level of effort was around a 3, the game board was much easier than expected. Next, following the pre-plan, came the graphics. I was able to use the classes from the game board, which greatly increased the efficiency, and I found that printing the graphical board only required running a loop across the positional array, with separate distinctions (color, shape) for the different String that was in question. I also created white circles in the back of each space to better distinguish them, and used these as placemats for creating and matching the colors. To start off, I only had light pastel colors assigned to the characters (chosen by the group). The icons part of the graphics was pushed to later on. This creation of the graphical game board was also completed by me. The next part of the plan was the mhos and the fences. Zage contributed the most to this part. She created an mhos move method for all of the actions an mho carried out, which consisted of following the user in many different ways. This part was tedious, and unorganized, but ended up turning out well! The mhos death was also complicated, as we were uncertain how and when to confirm the death. Zage also created the mpa position array, which held the coordinates of each of the mhos. Zage also created the code for the the interaction and the creation of the fences, which consisted of many “else” and “else if” statements. This level of effort was definitely around a 9, because of the confusion with the user coordinates, and how to implement the seconds steps of the mhos following. The last part of the plan was user interaction. Sabrina both found (through the internet two sources credited below) and implemented the KeyListener program into our code. Through that code, she linked the correct keys, and linked that to the user (SmileyFace) method with our moveOrDie method, where she inputted the correct coordinates for each letter move. Next, Sabrina created with game over and the you won methods. There were many issues with these at first, because we wanted to use the graphics outside of the paint method, but were unable to. It was difficult for us to figure out how to account for game over and you won requirements in the paint method, and make sure that paint method was called at the right times with repaint. Eventually, we figured out a forEachTurn method that ran repaint after each turn, whether it was a moveOrDie or a jump method, and therefore we were able to implement game over and you won. Also, Sabrina created the reset method for after game over and you won, which carried out many similar functions to the initializing methods, and so we combined most of their components. Lastly, I carried out the organization by creating helper methods for every available scenario. However, I did not create helper methods for mhoMove because of the iteration through the mpa array, and the amount of code that had to be written to redefine x and y outside in a helper method and then again in mhoMove. Also, a part of the beginning pre plan that got pushed to the end, I created the icons for each character, using the limited graphical knowledge I had of polygon, oval, and rectangle creation. The user is a content face, a play on the happy and sad face in the original design, while the mho is a cyclops ghost, a play on Pacman, which was created around the same time. The fence is a regular clipart fence, and the Legend is created with the same icons. The other legend, keys, and turns were created by Zage and I. Overall, our code structure mainly follows both the pre-plan and the specification file. 

MAJOR CHALLENGES: There were two major challenges I faced in the code, the repaint method and the mho movement. With the repaint method, I could not figure out how the issue of my code, where repaint was running constantly and causing the screen to flash repeatedly. Everything I changed had no effect, and I was left frustrated and at square one. I ended up using an older version of the code, and never figuring out why what I had done was incorrect until the end of the hivolts project. Turns out, the setBackground method had been the reason for the continuous flashing, and it didn’t have to do with repaint, which relieved the struggle. Next, Zage, Sabrina, and I all struggled to interpret the meaning of the specification file when it asked about the direction of the mho after diagonal facing the user is restricted. After many attempts on the whiteboard, and three different mho methods, we found a solution. Then, we added our own element to make the game easier, by allowing the mhos to die either vertically or horizontally without a diagonal dying element. This is shown by our else statements after checking the absolute value of the difference of the x and y coordinates. 
Overall, these were my group’s worst struggles, and I’m glad we overcame them and learned from them.

ACKNOWLEDGEMENTS: Thank you to https://docs.google.com/document/d/15wIsV7iMtdKvFh86yfYU549kk3w7CLjjCXu89KUU5l8/edit which provided us with the exact requirements for hivolts. Additionally, I would like to thank Zage, Sabrina, for completing this project with me, my other classmates for helping me struggle through each one of the areas of improvement and challenges, Kuszmaul for pushing me through the repaint code, and Tutorial Point, and Stack Overflow for providing me with sufficient java information to troubleshoot through difficult areas and implement the essential graphic and key parts of hivolts.

IMAGES: 
Old Hivolts: http://paleyontology.com/AP_CS/hivolts/
Our Hivolts: In Repository




